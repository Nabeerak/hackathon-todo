"""Task assistance service for AI-powered task breakdown and recommendations."""
from typing import Optional, List, Dict, Any
from datetime import datetime, timedelta
from sqlmodel import Session, select, or_
import logging
from openai import AsyncOpenAI
import json

from src.models import Task
from src.db import get_session

logger = logging.getLogger(__name__)


class TaskAssistanceService:
    """
    Service for AI-powered task assistance features.

    Provides task breakdown suggestions, next action recommendations,
    and intelligent task prioritization.
    """

    def __init__(
        self,
        user_id: int,
        api_key: str,
        model: str = "gpt-4o-mini",
        db_session: Optional[Session] = None
    ):
        """
        Initialize task assistance service.

        Args:
            user_id: User ID for task isolation
            api_key: OpenAI API key
            model: OpenAI model to use (default: gpt-4o-mini)
            db_session: Optional database session (for dependency injection)
        """
        self.user_id = user_id
        self.db_session = db_session
        self.client = AsyncOpenAI(api_key=api_key)
        self.model = model

    async def suggest_breakdown(
        self,
        task_title: str,
        task_description: Optional[str] = None,
        max_subtasks: int = 5
    ) -> Dict[str, Any]:
        """
        Generate subtask suggestions for complex tasks using GPT-4o-mini (T065).

        Uses AI to break down a complex task into manageable subtasks.

        Args:
            task_title: Main task title
            task_description: Optional task description for more context
            max_subtasks: Maximum number of subtasks to suggest (default: 5)

        Returns:
            Dictionary with breakdown suggestions:
            {
                "success": True,
                "task_title": str,
                "subtasks": [
                    {
                        "title": str,
                        "description": str,
                        "estimated_duration": str,  # e.g., "30 minutes", "2 hours"
                        "order": int
                    }
                ],
                "reasoning": str,  # AI's explanation for the breakdown
                "confidence": float
            }

        Examples:
            >>> service = TaskAssistanceService(user_id=1, api_key="sk-...")
            >>> result = await service.suggest_breakdown(
            ...     task_title="Plan quarterly offsite",
            ...     task_description="Organize team offsite for Q1 2025"
            ... )
            >>> len(result["subtasks"])
            5
            >>> "venue" in result["subtasks"][0]["title"].lower()
            True
        """
        try:
            # Build prompt for AI
            system_prompt = """You are a helpful task planning assistant. Your job is to break down complex tasks into smaller, actionable subtasks.

For each subtask, provide:
1. A clear, concise title (max 50 chars)
2. A brief description (1-2 sentences)
3. An estimated duration (e.g., "30 minutes", "2 hours", "1 day")
4. Logical ordering (numbered sequentially)

Return your response as JSON with this structure:
{
    "subtasks": [
        {
            "title": "string",
            "description": "string",
            "estimated_duration": "string",
            "order": number
        }
    ],
    "reasoning": "Brief explanation of how you broke down the task"
}

Keep subtasks actionable, specific, and achievable. Aim for 3-5 subtasks unless more are clearly needed."""

            user_message = f"Break down this task into subtasks:\n\nTitle: {task_title}"
            if task_description:
                user_message += f"\nDescription: {task_description}"

            user_message += f"\n\nProvide up to {max_subtasks} subtasks."

            # Call OpenAI
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_message}
                ],
                temperature=0.7,  # Slightly higher for creative breakdown
                max_tokens=800,
                response_format={"type": "json_object"}
            )

            # Parse response
            content = response.choices[0].message.content
            ai_response = json.loads(content)

            subtasks = ai_response.get("subtasks", [])
            reasoning = ai_response.get("reasoning", "Task breakdown generated by AI")

            # Validate and limit subtasks
            subtasks = subtasks[:max_subtasks]

            # Calculate confidence based on quality of response
            confidence = self._calculate_breakdown_confidence(subtasks, task_title)

            logger.info(
                f"Task breakdown generated for user {self.user_id}: "
                f"'{task_title}' â†’ {len(subtasks)} subtasks"
            )

            return {
                "success": True,
                "task_title": task_title,
                "subtasks": subtasks,
                "reasoning": reasoning,
                "confidence": confidence
            }

        except Exception as e:
            logger.error(
                f"Error generating task breakdown for user {self.user_id}: {str(e)}",
                exc_info=True
            )
            return {
                "success": False,
                "error": str(e),
                "task_title": task_title,
                "subtasks": [],
                "reasoning": "",
                "confidence": 0.0
            }

    def _calculate_breakdown_confidence(
        self,
        subtasks: List[Dict[str, Any]],
        task_title: str
    ) -> float:
        """Calculate confidence score for breakdown quality."""
        if not subtasks:
            return 0.0

        confidence = 1.0

        # Penalize if too few subtasks for complex-looking task
        if len(task_title.split()) > 5 and len(subtasks) < 3:
            confidence -= 0.2

        # Penalize if subtasks lack descriptions
        missing_descriptions = sum(1 for s in subtasks if not s.get("description"))
        confidence -= (missing_descriptions / len(subtasks)) * 0.3

        # Penalize if subtasks lack durations
        missing_durations = sum(1 for s in subtasks if not s.get("estimated_duration"))
        confidence -= (missing_durations / len(subtasks)) * 0.2

        return max(0.0, min(1.0, confidence))

    async def recommend_next_action(
        self,
        limit: int = 3
    ) -> Dict[str, Any]:
        """
        Prioritize tasks by urgency, importance, dependencies (T066).

        Analyzes user's task list and recommends what to work on next.

        Prioritization factors:
        - Due date proximity (if task has due date in future)
        - Task age (how long it's been pending)
        - Task completion history (patterns from AIContext)
        - Keyword urgency (e.g., "urgent", "asap", "deadline")

        Args:
            limit: Maximum number of tasks to recommend (default: 3)

        Returns:
            Dictionary with recommendations:
            {
                "success": True,
                "recommendations": [
                    {
                        "task": {...},  # Task object
                        "priority_score": float,  # 0.0-1.0
                        "reasoning": str,  # Why this task is recommended
                        "urgency_level": str  # "high", "medium", "low"
                    }
                ],
                "summary": str  # Overall recommendation summary
            }

        Examples:
            >>> service = TaskAssistanceService(user_id=1, api_key="sk-...")
            >>> result = await service.recommend_next_action(limit=3)
            >>> len(result["recommendations"])
            3
            >>> result["recommendations"][0]["priority_score"] > 0.5
            True
        """
        try:
            if self.db_session:
                return await self._recommend_next_action_impl(limit, self.db_session)
            else:
                with get_session() as db:
                    return await self._recommend_next_action_impl(limit, db)

        except Exception as e:
            logger.error(
                f"Error generating next action recommendations for user {self.user_id}: {str(e)}",
                exc_info=True
            )
            return {
                "success": False,
                "error": str(e),
                "recommendations": [],
                "summary": ""
            }

    async def _recommend_next_action_impl(
        self,
        limit: int,
        db: Session
    ) -> Dict[str, Any]:
        """Internal implementation of recommend_next_action."""
        # Get all pending tasks for user
        statement = select(Task).where(
            Task.user_id == self.user_id,
            Task.is_completed == False
        )
        pending_tasks = db.exec(statement).all()

        if not pending_tasks:
            return {
                "success": True,
                "recommendations": [],
                "summary": "You don't have any pending tasks. Great job staying on top of things!"
            }

        # Score each task
        task_scores = []
        for task in pending_tasks:
            score = self._calculate_priority_score(task)
            urgency = self._determine_urgency_level(score)
            reasoning = self._generate_priority_reasoning(task, score)

            task_scores.append({
                "task": {
                    "id": task.id,
                    "title": task.title,
                    "description": task.description,
                    "is_completed": task.is_completed,
                    "created_at": task.created_at.isoformat(),
                    "updated_at": task.updated_at.isoformat()
                },
                "priority_score": round(score, 2),
                "reasoning": reasoning,
                "urgency_level": urgency
            })

        # Sort by priority score (highest first)
        task_scores.sort(key=lambda x: x["priority_score"], reverse=True)

        # Get top recommendations
        recommendations = task_scores[:limit]

        # Generate summary
        summary = self._generate_recommendation_summary(recommendations, len(pending_tasks))

        logger.info(
            f"Next action recommendations generated for user {self.user_id}: "
            f"{len(recommendations)} tasks recommended out of {len(pending_tasks)} pending"
        )

        return {
            "success": True,
            "recommendations": recommendations,
            "summary": summary
        }

    def _calculate_priority_score(self, task: Task) -> float:
        """
        Calculate priority score for a task (0.0-1.0).

        Factors:
        - Task age: older tasks get higher scores
        - Keyword urgency: presence of urgent keywords
        - Title length: shorter titles might be simpler, quicker wins
        """
        score = 0.0

        # Age factor (max 0.4 points)
        # Tasks older than 7 days get max age score
        task_age_hours = (datetime.utcnow() - task.created_at).total_seconds() / 3600
        task_age_days = task_age_hours / 24
        age_score = min(task_age_days / 7, 1.0) * 0.4
        score += age_score

        # Urgency keyword factor (max 0.5 points)
        urgency_keywords = ["urgent", "asap", "critical", "important", "deadline", "today", "now"]
        title_lower = task.title.lower()
        desc_lower = (task.description or "").lower()

        urgency_matches = sum(
            1 for keyword in urgency_keywords
            if keyword in title_lower or keyword in desc_lower
        )
        urgency_score = min(urgency_matches / 3, 1.0) * 0.5
        score += urgency_score

        # Quick win factor (max 0.1 points)
        # Shorter task titles might indicate simpler tasks
        title_length = len(task.title.split())
        if title_length <= 3:
            score += 0.1

        return min(score, 1.0)

    def _determine_urgency_level(self, score: float) -> str:
        """Determine urgency level from priority score."""
        if score >= 0.7:
            return "high"
        elif score >= 0.4:
            return "medium"
        else:
            return "low"

    def _generate_priority_reasoning(self, task: Task, score: float) -> str:
        """Generate human-readable reasoning for priority score."""
        reasons = []

        # Check age
        task_age_days = (datetime.utcnow() - task.created_at).days
        if task_age_days >= 7:
            reasons.append(f"has been pending for {task_age_days} days")
        elif task_age_days >= 3:
            reasons.append("has been pending for several days")

        # Check urgency keywords
        urgency_keywords = ["urgent", "asap", "critical", "important", "deadline"]
        title_lower = task.title.lower()
        desc_lower = (task.description or "").lower()

        found_keywords = [
            kw for kw in urgency_keywords
            if kw in title_lower or kw in desc_lower
        ]
        if found_keywords:
            reasons.append(f"contains urgency indicator: '{found_keywords[0]}'")

        # Check for quick win
        if len(task.title.split()) <= 3:
            reasons.append("appears to be a quick win")

        if not reasons:
            reasons.append("is on your pending list")

        return "This task " + " and ".join(reasons)

    def _generate_recommendation_summary(
        self,
        recommendations: List[Dict[str, Any]],
        total_pending: int
    ) -> str:
        """Generate overall summary for recommendations."""
        if not recommendations:
            return "No recommendations at this time."

        top_task = recommendations[0]["task"]["title"]
        urgency = recommendations[0]["urgency_level"]

        if urgency == "high":
            summary = f"I recommend starting with '{top_task}' - it's your highest priority task."
        elif urgency == "medium":
            summary = f"Consider working on '{top_task}' next - it's a good candidate to tackle soon."
        else:
            summary = f"'{top_task}' could be a good next task to work on."

        if total_pending > len(recommendations):
            summary += f" You have {total_pending - len(recommendations)} other tasks pending."

        return summary
